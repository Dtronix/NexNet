# <img src="./docs/images/logo-256.png" width="48"> NexNet [![Action Workflow](https://github.com/Dtronix/NexNet/actions/workflows/dotnet.yml/badge.svg)](https://github.com/Dtronix/NexNet/actions)

NexNet is a .NET real-time asynchronous networking library, providing developers with the capability to seamlessly incorporate server and client bidirectional, multiplexing, and event-driven functionality into applications. This framework streamlines the transmission of data bidirectionally between servers and clients with resilient connections.

## Features
- Automatic reconnection upon timeout or socket losing connection.
- High performance Socket and Pipeline usage.
- Multiple transports and easy extensibility.
- Strong Typed Hubs & Clients.
- Server <-> Client communication
  - Synchronized collections (INexusList)
  - Cancellable Invocations
  - Streaming byte data via `INexusDuplexPipe` with built-in congestion control.
  - Streaming classes/structs data via `NexusChannel<T>` and simplified reading with IAsyncEnumerable
  - Multiplexing method invocations
  - Proxies can return:
    - void for "fire and forget" invocation situations such as notifications.
    - ValueTask for waiting for invocation completion.
    - ValueTask<T> which will return a value from the remote invocation method.
- Server can message multiple connected clients with a single invocation.
- Automatic reconnection of clients upon timeout or loss of connection.
- Thorough use of ValueTasks in hot paths for reduced invocation overhead.
- Ping system to detect timeouts from client and server side.
- No reflection. All hubs and proxies are Source Generated by the NexNet.Generator project.  This allows for fast execution and easier tracing of bugs.
- Full asynchronous TPL usage throughout socket reading/writing, processing and execution of invocations and their return values.
- Minimal external package requirements.
- Optional server integration with ASP.NET Core, which enables features such as authentication, proxying, and running multiple Nexus servers on the same application.  

## Installation
Installation through NuGet is the most common method of installation.  See below for the NuGet packages.

| Name                                                                  | NuGet                                                                                                                                 | Description                                                                   |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| [`NexNet`](https://www.nuget.org/packages/NexNet)                     | [![NexNet](https://img.shields.io/nuget/v/NexNet.svg?maxAge=60)](https://www.nuget.org/packages/NexNet)                               | Core project required for all Client and Server interactions.                 |
| [`NexNet.Generator`](https://www.nuget.org/packages/NexNet.Generator) | [![NexNet.Generator](https://img.shields.io/nuget/v/NexNet.Generator.svg?maxAge=60)](https://www.nuget.org/packages/NexNet.Generator) | Source Code Generator for Client and Servers.                                 |
| [`NexNet.Quic`](https://www.nuget.org/packages/NexNet.Quic)           | [![NexNet.Quic](https://img.shields.io/nuget/v/NexNet.Quic.svg?maxAge=60)](https://www.nuget.org/packages/NexNet.Quic)                | Adds QUIC client and servers to NexNet.  See below for requirements.          |
| [`NexNet.Asp`](https://www.nuget.org/packages/NexNet.Asp)             | [![NexNet.Asp](https://img.shields.io/nuget/v/NexNet.Asp.svg?maxAge=60)](https://www.nuget.org/packages/NexNet.Asp)                   | Adds integration into ASP.NET for server WebSocket and HttpSocket transports. |

Add the `NexNex.Generator` package to the `Client` and `Server` projects and the `NexNex` package to the `Shared` project.  Once complete, reference the `Shared` project in the `Client` and `Server` project.
Adding packages to your existing project can be done through the `dotnet add package NexNet` command.
The `NexNet.Generator` is a Source Code Generator which will take the provided interfaces and create the required invocation system.  This is the system that allows for the elimination of reflection in the `Client` and `Server` projects and also allows for the final generated classes to be AOT friendly.
The code below will need to be used to reference the `NexNet.Generator` in your `.csproj`.  It will normally be created automatically when you add the NuGet package.
```xml
<PackageReference Include="NexNet.Generator" Version="*-*">
  <PrivateAssets>all</PrivateAssets>
  <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
</PackageReference>
```

## Setup
Common client and server interfaces should reside in a separate `Shared` project, referenceable by other projects.

## Usage

#### Base classes
```csharp
interface IInvocationSampleClientNexus
{
    ValueTask<string> GetUserName();
}

interface IInvocationSampleServerNexus
{
    void UpdateInfo(int userId, int status, string? customStatus);
    ValueTask UpdateInfoAndWait(int userId, int status, string? customStatus);
    ValueTask<int> GetStatus(int userId);
}


[Nexus<IInvocationSampleClientNexus, IInvocationSampleServerNexus>(NexusType = NexusType.Client)]
partial class InvocationSampleClientNexus
{
    public ValueTask<string> GetUserName()
    {
        return new ValueTask<string>("Bill");
    }
}

[Nexus<IInvocationSampleServerNexus, IInvocationSampleClientNexus>(NexusType = NexusType.Server)]
partial class InvocationSampleServerNexus
{
    public void UpdateInfo(int userId, int status, string? customStatus)
    {
        // Do something with the data.
    }

    public ValueTask UpdateInfoAndWait(int userId, int status, string? customStatus)
    {
        // Do something with the data.
        return default;
    }

    public ValueTask<int> GetStatus(int userId)
    {
        return new ValueTask<int>(1);
    }
}

```
#### Client and Server Usage
```csharp
var client = InvocationSampleClientNexus.CreateClient(ClientConfig, new InvocationSampleClientNexus());
var server = InvocationSampleServerNexus.CreateServer(ServerConfig, () => new InvocationSampleServerNexus());

await server.StartAsync();
await client.ConnectAsync();

await client.Proxy.UpdateInfoAndWait(1, 2, "Custom Status");
```
## Benchmarks
```
BenchmarkDotNet v0.15.2, Windows 11 (10.0.26100.4770/24H2/2024Update/HudsonValley)
AMD Ryzen 9 3900X 3.80GHz, 1 CPU, 24 logical and 12 physical cores
.NET SDK 9.0.201
  [Host]     : .NET 9.0.3 (9.0.325.11113), X64 RyuJIT AVX2
  Job-FJSVHN : .NET 9.0.3 (9.0.325.11113), X64 RyuJIT AVX2

Platform=X64  Runtime=.NET 9.0
```

| Method                               |    Mean |   Error |  StdDev |     Op/s | Allocated |
|--------------------------------------|--------:|--------:|--------:|---------:|----------:|
| InvocationNoArgument                 | 44.9 us | 0.86 us | 0.84 us | 22,253.1 |     569 B |
| InvocationUnmanagedArgument          | 48.9 us | 0.96 us | 1.52 us | 20,458.6 |     625 B |
| InvocationUnmanagedMultipleArguments | 47.2 us | 0.92 us | 1.16 us | 21,168.6 |     676 B |
| InvocationNoArgumentWithResult       | 43.9 us | 0.63 us | 0.56 us | 22,774.8 |     609 B |
| InvocationWithDuplexPipe_Upload      | 65.9 us | 1.31 us | 1.22 us | 15,179.3 |   16262 B |

## Method Invocation Table
Some methods are handled differently based upon the arguments passed and there are limitations placed upon the types of arguments which can be used together.  Most of these incompatibilities handled with Diagnostic Errors provided by the `NexNet.Generator`.  Below is a table which shows valid combinations of arguments and return values.

|                    | CancellationToken | INexusDuplexPipe | INexusChannel<T> | Args |
|--------------------|-------------------|------------------|------------------|------|
| void               |                   |                  |                  | X    |
| ValueTask          | X                 |                  |                  | X    |
| ValueTask          |                   | X                | X                | X    |
| ValueTask&lt;T&gt; | X                 |                  |                  | X    |

Notes:
- `CancellationToken`s can't be combined with `NexusDuplexPipe` nor `INexusChannel<T>` due to pipes/channels having built-in cancellation/completion notifications.
- `CancellationToken` must be at the end of the argument list like standard conventions.

### Synchronized Collection Usage
The synchronized collections exists on the server nexus and is accessed through the server proxy on the client.  Collections must be decorated with NexusCollectionAttribute, otherwise the Server nexus it will throw.  Synchronized collections are only allowed on the server nexus.  Collections are to be configured as either `BiDrirectional` or `ServerToClient`.

INexusList offers a list-like API but with each mutation routed to the server.  Methods like AddAsync, InsertAsync, RemoveAsync, RemoveAtAsync, ClearAsync, MoveAsync, and ReplaceAsync all return Task, where the completion indicates acceptance or rejection by the server (noop).  All data accessed in the synchronous methods access the current state on the client.

``` cs
public partial interface IClientNexus { }
public partial interface IServerNexus
{
    [NexusCollection(NexusCollectionMode.BiDrirectional)]
    INexusList<int> IntList { get; }
}

[Nexus<IClientNexus, IServerNexus>(NexusType = NexusType.Client)]
public partial class ClientNexus { }

[Nexus<IServerNexus, IClientNexus>(NexusType = NexusType.Server)]
public partial class ServerNexus { }

await ServerNexus.CreateServer(..., ...).StartAsync();

var client = ClientNexus.CreateClient(..., ...);
await client.ConnectAsync();

// Connect to the list (internally starts a duplex pipe for communication).
await client.Proxy.IntList.ConnectAsync();

// Add the value to the synchronized collection. This will return upon acknowledgement by the server of addition.
await client.Proxy.IntList.AddAsync(12345);
```

## Duplex Pipe Usage
NexNet has a limitation where the total serialized argument's bytes passed can't exceed 65,535 bytes. To address this, NexNet comes with built-in handling for duplex pipes via the `NexusDuplexPipe` argument, allowing you to both send and receive byte arrays. This is especially handy for continuous data streaming or when dealing with large data, like files.  If you need to send larger data, you should use the `NexusDuplexPipe` arguments to handle the transmission.

As with System.IO.Pipelines, the `INexusDuplexPipe` is not thread safe.  You are responsible for ensuring member calls to not overlap.

## Channels
Building upon the Duplex Pipes infrastructure, NexNet provides two channel structures to allow transmission/streaming of data structures via the `INexusDuplexChannel<T>` and `INexusDuplexUnmanagedChannel<T>` interfaces.

Several extension methods have been provided to allow for ease of reading and writing of entire collections (e.g. selected table rows).
- `NexusChannelExtensions.WriteAndComplete<T>(...)`: Writing a collection to either a `INexusDuplexChannel<T>` or `INexusChannelWriter<T>` with optional batch sizes for optimized sending.
- `NexusChannelExtensions.ReadUntilComplete<T>(...)`: Reads from either a `INexusDuplexChannel<T>` or a `INexusChannelReader<T>` with an optional initial collection size to reduce collection resizing.

#### INexusDuplexChannel<T>
The `INexusDuplexChannel<T>` interface provides data transmission for all types which can be serialized by [MemoryPack](https://github.com/Cysharp/MemoryPack#built-in-supported-types).  This is the interface tuned for general usage and varying sized payloads.  If you have an [unmanaged types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types) to send, make sure to use the  `INexusDuplexUnmanagedChannel<T>` interface instead as it is fine-tuned for performance of those simple types

Unlike the `INexusDuplexPipe`, the `INexusDuplexChannel<T>` is thread safe for writing.  Reading should be done on a single thread.

Acquisition is handled through the `INexusClient.CreateChannel<T>` or `SessionContext<T>.CreateChannel<T>` methods.  If an instance is created, it should be disposed to release held resources.

#### INexusDuplexUnmanagedChannel<T> (Unmanaged Types)
The `INexusDuplexUnmanagedChannel<T>` interface provides data transmission for [unmanaged types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types).  This is good for mainly simple types and structs.  This interface should always be used over the `INexusDuplexChannel<T>` if the type is an unmanaged type as it is fine-tuned for performance.

Acquisition is handled through the `INexusClient.CreateUnmanagedChannel<T>` or `SessionContext<T>.CreateUnmanagedChannel<T>` methods.  If an instance is created, it should be disposed to release held resources.

#### IAsyncEnumerable Usage

The preferred method of reading channels is using the IAsyncEnumerable on the provided INexusChannelReader.  This allows for the most efficient buffering of data while reading and simplifies channel closure, whether graceful or not.
```csharp
var writer = await pipe.GetUnmanagedChannelWriter<int>();
await foreach (var msg in await pipe.GetChannelReader<ComplexMessage>())
{
    // Do something with the message.
}
```

## Lifetimes
New hub instances are created for each session that connects to the hub. The hub manages the communication between the client and the server and remains active for the duration of the session. Once the session ends, either due to client disconnection, error or session timeout, the hub instance is automatically disposed of by NexNet.

Each session is assigned a unique hub instance, ensuring that data is not shared between different sessions. This design guarantees that each session is independently handled, providing a secure and efficient communication mechanism between the client and server.

## Versioning

Nexus servers can optionally have versioning built into their interface definitions.  To enable versioning, use the `NexusVersionAttribute` to decorate the interfaces that compose the base NexusServer interface.  Inheriting from a lower version interface to a higher interface allows NexNet to build a hierarchy of version interfaces.  Any of the versioned interfaces can be built into a dedicated server, but normally you will inheit the latest interface version.  This allows a client which has a lower server interface version to connect to a server with running with a newer version.

Clients can't be versioned and is a server only feature.  The versioning system now prevents unauthorized method invocations by validating method IDs against the client's declared version capabilities.

All invoked methods are validated against the connected client's server interface.  If a client tries to invoke a method that is not part of the client's specified server interface, the client will be disconnected.

When versioning, NexNet comes with some caveats:
1. All interfaces must have a version string which must be used during connection.
2. All Methods and NexusCollections must have `NexusMethodAttribute` set with a unique method ID (e.g., `[NexusMethod(1)]`).
3. Method and NexusCollections must not be changed in the interface after setting a version.

While not required, it is highly suggested that you utilize the `HashLock` argument of the `NexusVersionAttribute`.  The purpose of it is to ensure that once your interface API is ready for shipping, it can not be changed without notice.  Once a `HashLock` is set, if any of the arguments, MemoryPack members (including union changes), return values, or method types are changed, then the analyzer will set a compile error.

It is suggested that during development, that the `HashLock` property not be set  This will ensure that you can modify the interface without having to keep the HashLock in sync.

### Versioning Security Features
- Runtime validation of method invocations against client version capabilities
- Servers maintain `VersionMethodHashSet` for valid method+version combinations
- Unauthorized method access results in immediate disconnection with `ProtocolError`
- Connection establishment includes invocation hash verification for compatibility
- Method IDs combined with version hashes create unique identifiers for each version+method combination
- Source generator creates optimized lookup tables for minimal performance overhead

### Versioning Sample

See below for a sample with two server interface versions, and two clients which implement V1.0 and V2.0 of the server interfaces.  This configuration allows the V1 and V2 clients to connect to the same server while only restricting which methods can be invoked due to the interface they implement.

```csharp
// V1 Server Interface - Initial version with one method
[NexusVersion(Version = "v1.0", HashLock = -2031775281)]
public interface IVersioningNexusServerV1
{
    [NexusMethod(1)]
    ValueTask<bool> GetStatus();
}

// V1 Server Implementation
[Nexus<IVersioningNexusServerV1, IVersioningNexusClient>(NexusType = NexusType.Server)]
public partial class NexusServerV1
{
    public ValueTask<bool> GetStatus()
    {
        return ValueTask.FromResult(true);
    }
}

// V2 Server Interface - Inherits from V1 and adds new method
[NexusVersion(Version = "v2.0", HashLock = -1210855623)]
public interface IVersioningNexusServerV2 : IVersioningNexusServerV1
{
    [NexusMethod(2)]
    ValueTask<string> GetServerInfo();
}

// V2 Server Implementation
[Nexus<IVersioningNexusServerV2, IVersioningNexusClient>(NexusType = NexusType.Server)]
public partial class VersioningNexusServerV2
{
    // Implements V1 method
    public ValueTask<bool> GetStatus()
    {
        return ValueTask.FromResult(true);
    }

    // New V2 method
    public ValueTask<string> GetServerInfo()
    {
        return ValueTask.FromResult("Server v2.0");
    }
}

// Client interface (same for both versions)
public interface IVersioningNexusClient
{
    ValueTask OnServerMessage(string message);
}

// V1 Client (can only connect to servers supporting V1)
[Nexus<IVersioningNexusClient, IVersioningNexusServerV1>(NexusType = NexusType.Client)]
public partial class VersioningNexusClientV1
{
    public ValueTask OnServerMessage(string message)
    {
        Console.WriteLine($"Received: {message}");
        return ValueTask.CompletedTask;
    }
}

// V2 Client (can connect to servers supporting V2)
[Nexus<IVersioningNexusClient, IVersioningNexusServerV2>(NexusType = NexusType.Client)]
public partial class VersioningNexusClientV2
{
    public ValueTask OnServerMessage(string message)
    {
        Console.WriteLine($"Received: {message}");
        return ValueTask.CompletedTask;
    }
}

public class VersioningSample : INexusSample
{
    public async Task Run()
    {
        var serverConfig = new TcpServerConfig
        {
            EndPoint = new IPEndPoint(IPAddress.Loopback, 1234)
        };
        
        // Server supporting both V1 and V2 clients
        var server = VersioningNexusServerV2.CreateServer(serverConfig, () => new VersioningNexusServerV2());
        await server.StartAsync();

        // V1 Client connecting to server
        var clientConfig = new TcpClientConfig()
        {
            EndPoint = new IPEndPoint(IPAddress.Loopback, 1234)
        };
        
        var clientV1 = VersioningNexusClientV1.CreateClient(clientConfig, new VersioningNexusClientV1());
        var result = await clientV1.TryConnectAsync();

        if (result.Success)
        {
            // Can call V1 methods
            Console.WriteLine(await clientV1.Proxy.GetStatus());
            // Cannot call V2 methods
        }

        // V2 Client connecting to server
        var clientV2 = VersioningNexusClientV2.CreateClient(clientConfig, new VersioningNexusClientV2());
        var result2 = await clientV2.TryConnectAsync();

        if (result2.Success)
        {
            // Can call both V1 and V2 methods
            Console.WriteLine(await clientV2.Proxy.GetStatus());
            Console.WriteLine(await clientV2.Proxy.GetServerInfo());
        }
    }
}
```

## Transports Supported
- Unix Domain Sockets (UDS)
- TCP
- TLS over TCP
- QUIC (UDP)
- WebSockets
- HttpSockets (Custom HTTP Negotiation)

Unix Domain Sockets (UDS)
Unix Domain Sockets offer the highest efficiency for inter-process communication due to minimal overhead. UDS are suitable when processes communicate on the same host, providing optimal performance without network stack overhead.

#### TCP
TCP supports reliable network and internet communication. It is the fastest transport method following Unix Domain Sockets, offering reliable, ordered packet delivery over IP networks.

#### TLS over TCP
TLS over TCP enables secure, encrypted communication using SslStream on both server and client ends. While it maintains good performance, it introduces additional overhead due to encapsulation—using a Socket wrapped by a NetworkStream, further wrapped by an SslStream—making it less performant compared to UDS and plain TCP.

#### QUIC (UDP)
QUIC is a reliable UDP-based protocol guaranteeing packet transmission, order integrity, and resilience against IP and port changes, such as transitions from Wi-Fi to cellular connections. Implementation requires installing the libmsquic library (sudo apt install libmsquic on Ubuntu) and including the NexNet.Quic NuGet package.

#### WebSockets (ASP.NET Core)
WebSockets enable real-time, bidirectional data exchange between client and server over persistent TCP connections. NexNet utilizes Binary WebSocket streams, which introduce a minor overhead—specifically, 4 bytes per message header/data frame transmitted.

#### HttpSockets (ASP.NET Core - Custom HTTP Negotiation)
HttpSockets establish a bidirectional, long-lived data stream by upgrading a standard HTTP connection. Similar to WebSockets in connection upgrade methodology, HttpSockets differ by eliminating WebSocket-specific message header overhead. After connection establishment, the stream is directly managed by the NexNet server, minimizing transmission overhead.  The server requires an ASP.NET Core server.

Additional transports can be added wit relative ease as long as the new transport guarantees order and transmission.

## Transport Selection Guide

| Scenario                 | Recommended Transport | Reason                                          |
|--------------------------|-----------------------|-------------------------------------------------|
| Same machine IPC         | Unix Domain Sockets   | Highest performance, no network overhead        |
| Local network            | TCP                   | Simple, reliable, fast                          |
| Internet/WAN             | TLS over TCP          | Secure, widely supported                        |
| Mobile/unstable networks | QUIC                  | Connection migration, better congestion control |
| Web applications         | WebSockets            | Browser compatibility, firewall-friendly        |
| Reverse proxy setups     | HttpSockets           | Lower overhead than WebSockets                  |

Additional information about the wire protocol can be found in the [Transport-Headers](docs/Transport-Headers.md) documentation.

## ASP.NET Server Integration

The NexNet.Transports.Asp package allows direct integration of NexNet servers into ASP.NET Core applications. It integrates into middleware pipelines, simplifying configuration, routing, and dependency injection.

The package supports integration of NexNet server using WebSocket and HttpSocket connections, enabling easy management and proxying via common reverse proxies such as Nginx. This allows for potential improved connection handling, load balancing, and security.

Abstracting the server away from direct connections can have some advantages such as th following:
- Proxying HTTP connections through reverse proxies provides SSL/TLS termination, reducing cryptographic overhead on application servers.
- Enables centralized traffic management, simplifying enforcement of security policies (e.g., rate-limiting, IP allowlisting, header validation).
- Facilitates consistent logging, monitoring, and metrics collection at proxy level, aiding operational visibility and troubleshooting.
- Provides an additional layer for DDoS mitigation and protection against common web vulnerabilities.
- Allows for additional authentication with the connection prior to handing the connection to the NexusServer.

### Sample ASP.NET Server
```csharp
var builder = WebApplication.CreateBuilder(args);
// If the connection is proxied setup the header forwards.
builder.Services.Configure<ForwardedHeadersOptions>(o => o.ForwardedHeaders = ForwardedHeaders.All);

// Optionally add authentication.  Bearer shown for simplicity.
builder.Services.AddAuthentication().AddBearerToken("BearerTokenScheme", ...);
builder.Services.AddAuthorization();

// Add the Nexus server to the services.  This allows for DI on the ServerNexus constructor
builder.Services.AddNexusServer<ServerNexus, ServerNexus.ClientProxy>();

var app = builder.Build();

// Eanble the headers and authentication.
app.UseForwardedHeaders();
app.UseAuthentication();
app.UseAuthorization();

// Enable, configure and start the nexus. Use UseWebSocketNexusServerAsync for a WebSocket connection instead.
await app.UseHttpSocketNexusServerAsync<ServerNexus, ServerNexus.ClientProxy>(c =>
{
    // Set the connection mapping path.
    c.Path = "/nexus";
    
    // Optionally enable authentication and the scheme to apply.
    c.AspEnableAuthentication = true;
    c.AspAuthenticationScheme = "BearerTokenScheme";
}).StartAsync(app.Lifetime.ApplicationStopped); // Stop the Nexus server upon ASP stopping.
```

### Sample Client Connecting to ASP.NET Server
```csharp
// Use WebSocketClientConfig for a WebSocket connection.
var config = new HttpSocketClientConfig()
{
    Url = new Uri("http://127.0.0.1:9001/nexus"), // The URI will need to change to ws:// or wss:// for a websocket connection
    AuthenticationHeader = new AuthenticationHeaderValue("Bearer", "SecretTokenValue") // Optional auth header.
};

// Create the client with the configuration.
var client = ClientNexus.CreateClient(config, new ClientNexus());

// Await the connection.  Will throw if the optional authentication fails.
await client.ConnectAsync();
```

### ASP.NET Proxying Configurations
A non-exhaustive list of proxy configurations that are known to work with ASP.NET
#### Nginx
Below is a simple configuration that will allow for proxy integration with an ASP.NET Core server
```
server {
    server_name example.com;
    location / {
        proxy_pass         http://backend;
        proxy_http_version 1.1;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header   Upgrade $http_upgrade;
        proxy_set_header   Connection $connection_upgrade;
        proxy_set_header   Host $host;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
    }
```

## Dependencies
- [MemoryPack](https://github.com/Cysharp/MemoryPack) for message serialization. 
- Internally packages Marc Gravell's [Pipelines.Sockets.Unofficial](https://github.com/Dtronix/Pipelines.Sockets.Unofficial/tree/nexnet-v1) with additional performance modifications for Pipeline socket transports.
- Quic protocol requires `libmsquic` on *nix based systems. [Windows Support](https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/quic/quic-overview)

