using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace NexNet.Generator;

partial class NexusGenerator
{
    internal static void Generate(TypeDeclarationSyntax syntax, Compilation compilation, GeneratorContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        if (typeSymbol == null)
        {
            return;
        }

        // verify is partial
        if (!IsPartial(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        // nested is not allowed
        if (IsNested(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NestedNotAllow, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        // nested is not allowed
        if (IsNested(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NestedNotAllow, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        var nexusMeta = new NexusMeta(typeSymbol);

        // ReportDiagnostic when validate failed.
        if (!nexusMeta.Validate(syntax, context))
        {
            return;
        }

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        var sb = SymbolUtilities.GetStringBuilder();

        /*
        // <auto-generated/>
#nullable enable
#pragma warning disable CS0108 // hides inherited member
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment
#pragma warning disable CS8602
#pragma warning disable CS8604 // Possible null reference argument for parameter
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method
#pragma warning disable CS8765 // Nullability of type of parameter
#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member
#pragma warning disable CA1050 // Declare types in namespaces.*/
        sb.AppendLine(@"// <auto-generated/>
#nullable enable
");

        nexusMeta.EmitNexus(sb);

        var code = sb.ToString();

        SymbolUtilities.ReturnStringBuilder(sb);

        context.AddSource($"{fullType}.Nexus.g.cs", code);
    }

    static bool IsPartial(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    static bool IsNested(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Parent is TypeDeclarationSyntax;
    }


}

partial class NexusMeta
{
    private string EmitServerClientName() => NexusAttribute.IsServer ? "Server" : "Client";
    public void EmitNexus(StringBuilder sb)
    {
        var collections = NexusAttribute.IsServer ? NexusInterface.AllCollections : ProxyInterface.AllCollections;
        sb.AppendLine($$"""
namespace {{Symbol.ContainingNamespace}} 
{
    /// <summary>
    /// Nexus used for handling all {{EmitServerClientName()}} communications.
    /// </summary>
    partial class {{TypeName}} : 
        global::NexNet.Invocation.{{EmitServerClientName()}}NexusBase<{{this.Namespace}}.{{this.TypeName}}.{{this.ProxyInterface.ProxyImplName}}>, 
        {{this.NexusInterface.Namespace}}.{{this.NexusInterface.TypeName}}, 
        global::NexNet.Invocation.IInvocationMethodHash,
        global::NexNet.Collections.ICollectionConfigurer
    {
    
""");
        if (NexusAttribute.IsServer)
        {
            foreach (var collection in NexusInterface.Collections)
            {
                collection.EmitNexusAccessor(sb);
                sb.AppendLine();
            }
            
            sb.AppendLine($$"""
        /// <summary>
        /// Creates an instance of the server for this nexus and matching client.
        /// </summary>
        /// <param name="config">Configurations for this instance.</param>
        /// <param name="nexusFactory">Factory used to instance nexuses for the server on each client connection. Useful to pass parameters to the nexus.</param>
        /// <returns>NexusServer for handling incoming connections.</returns>
        public static global::NexNet.NexusServer<{{this.Namespace}}.{{TypeName}}, {{this.Namespace}}.{{TypeName}}.{{this.ProxyInterface.ProxyImplName}}> CreateServer(global::NexNet.Transports.ServerConfig config, global::System.Func<{{this.Namespace}}.{{TypeName}}> nexusFactory)
        {
            return new global::NexNet.NexusServer<{{this.Namespace}}.{{TypeName}}, {{this.Namespace}}.{{TypeName}}.{{this.ProxyInterface.ProxyImplName}}>(config, nexusFactory);
        }
""");
        }
        else
        {
            sb.AppendLine($$"""
        /// <summary>
        /// Creates an instance of the client for this nexus and matching server.
        /// </summary>
        /// <param name="config">Configurations for this instance.</param>
        /// <param name="nexus">Nexus used for this client while communicating with the server. Useful to pass parameters to the nexus.</param>
        /// <returns>NexusClient for connecting to the matched NexusServer.</returns>
        public static global::NexNet.NexusClient<{{this.Namespace}}.{{TypeName}}, {{this.Namespace}}.{{TypeName}}.{{this.ProxyInterface.ProxyImplName}}> CreateClient(global::NexNet.Transports.ClientConfig config, {{TypeName}} nexus)
        {
            return new global::NexNet.NexusClient<{{this.Namespace}}.{{TypeName}}, {{this.Namespace}}.{{TypeName}}.{{this.ProxyInterface.ProxyImplName}}>(config, nexus);
        }
""");
        }

        sb.AppendLine($$"""

        protected override async global::System.Threading.Tasks.ValueTask InvokeMethodCore(global::NexNet.Messages.IInvocationMessage message, global::System.Buffers.IBufferWriter<byte>? returnBuffer)
        {
            global::System.Threading.CancellationTokenSource? cts = null;
            global::NexNet.Pipes.INexusDuplexPipe? duplexPipe = null;
            var methodInvoker = global::System.Runtime.CompilerServices.Unsafe.As<global::NexNet.Invocation.IMethodInvoker>(this);
            try
            {
""");
        if (NexusInterface.AllMethods!.Length > 0 || NexusInterface.AllCollections!.Length > 0)
        {
            sb.AppendLine($$"""
                switch (message.MethodId)
                {
""");


            foreach (var method in NexusInterface.AllMethods)
            {
                sb.Append($$"""
                    case {{method.Id}}:
                    {
                        // {{method}}

""");
                method.EmitNexusInvocation(sb, this.ProxyInterface, this);
                sb.AppendLine("""
                        break;
                    }
""");
            }

            if (NexusInterface.Collections.Length > 0)
            {
                sb.AppendLine("                    // Collection invocations:");
            }
            
            for (int i = 0; i < NexusInterface.Collections.Length; i++)
            {
                sb.Append($$"""
                    case {{NexusInterface.Collections[i].Id}}:
                    {
                        // {{NexusInterface.Collections[i]}}
""");
                NexusInterface.Collections[i].EmitNexusInvocation(sb);
                sb.AppendLine("""
                        break;
                    }
""");
            }

            sb.AppendLine($$"""
                }
""");
        }
        else
        {
            sb.AppendLine("                // No methods.");
        }

        sb.AppendLine($$"""
            }
            finally
            {
                if(cts!= null)
                {
                    methodInvoker.ReturnCancellationToken(message.InvocationId);
                }

                if (duplexPipe != null)
                {
                    await methodInvoker.ReturnDuplexPipe(duplexPipe);
                }
            }

        }
        
""");
        sb.AppendLine($$"""
        /// <summary>
        /// Configures the nexus collections, if there are any.
        /// </summary>
        /// <param name="manager">Manager for configuring collections</param>
        static void global::NexNet.Collections.ICollectionConfigurer.ConfigureCollections(global::NexNet.Invocation.IConfigureCollectionManager manager)
        {
""");
        if(collections!.Length > 0)
        {
            foreach (var collection in collections)
            {
                collection.EmitCollectionConfigure(sb);
            }
        }
        else
        {
            sb.AppendLine("            // No collections configured.");
        }
    
        sb.AppendLine($$"""
            manager.CompleteConfigure();
        }
        
""");   
        sb.Append($$"""
        /// <summary>
        /// Hash for this the methods on this proxy or nexus.  Used to perform a simple client and server match check.
        /// </summary>
        static int global::NexNet.Invocation.IInvocationMethodHash.MethodHash { get => {{this.NexusInterface.GetHash()}}; }
        
        /// <summary>
        /// Hash table for all the versions that this nexus implements.
        /// </summary>
        static global::System.Collections.Frozen.FrozenDictionary<string, int> global::NexNet.Invocation.IInvocationMethodHash.VersionHashTable { get; } = 
""");

        if (NexusAttribute.IsServer)
        {
            sb.AppendLine(
                "global::System.Collections.Frozen.FrozenDictionary.ToFrozenDictionary(new global::System.Collections.Generic.KeyValuePair<string, int>[] {");
            foreach (var versionInterface in this.NexusInterface.Versions)
            {
                sb.Append("            new(\"").Append(versionInterface.VersionAttribute.Version).Append("\", ")
                    .Append(versionInterface.GetHash()).AppendLine("),");
            }
        
            sb.AppendLine("""
        });
        
        static bool global::NexNet.Invocation.IInvocationMethodHash.ValidateMethodVersion(int version, int methodId)
        {
""");
            foreach (var versionInterface in this.NexusInterface.Versions)
            {
                sb.Append("            if (version == ").Append(versionInterface.GetHash()).AppendLine(")");
                sb.AppendLine("                return methodId switch");
                sb.AppendLine("                {");

                foreach (var method in versionInterface.AllMethods)
                {
                    sb.Append("                    ").Append(method.Id).AppendLine(" => true,");
                }
                sb.AppendLine("                    _ = false");
                sb.AppendLine("                };");
            }
            sb.AppendLine("        };");
            
        }
        else
        {
            sb.AppendLine("global::System.Collections.Frozen.FrozenDictionary<string, int>.Empty;");
        }

        
        // We don't want to emit the proxy invocation on the server, only on the client.
        ProxyInterface.EmitProxyImpl(sb, NexusAttribute.IsServer ? null : ProxyInterface);

        sb.AppendLine($$"""
    }
}
""");
    }
    
    public override string ToString()
    {
        return this.TypeName;
    }
}



partial class MethodMeta
{
    /// <summary>
    /// Emit the code for the the nexus.
    /// </summary>
    /// <param name="sb"></param>
    /// <param name="proxyImplementation"></param>
    /// <param name="nexus"></param>
    public void EmitNexusInvocation(StringBuilder sb, InvocationInterfaceMeta proxyImplementation, NexusMeta nexus)
    {
        // Create the cancellation token parameter.
        if (CancellationTokenParameter != null)
        {
            //sb.AppendLine($"                        var methodInvoker = global::System.Runtime.CompilerServices.Unsafe.As<global::NexNet.Invocation.IMethodInvoker<{nexus.Namespace}.{nexus.TypeName}.{proxyImplementation.ProxyImplName}>>(this);");
            sb.AppendLine("                        cts = methodInvoker.RegisterCancellationToken(message.InvocationId);");
        }

        // Deserialize the arguments.
        if (SerializedParameters > 0)
        {
            sb.Append("                        var arguments = message.DeserializeArguments<global::System.ValueTuple<");
            for (var i = 0; i < Parameters.Length; i++)
            {
                if (Parameters[i].SerializedType == null)
                    continue;

                sb.Append(Parameters[i].SerializedType).Append(", ");
            }
            sb.Remove(sb.Length - 2, 2);

            sb.AppendLine(">>();");
        }

        // Register the duplex pipe if we have one.
        if (UtilizesPipes)
        {
            sb.Append("                        duplexPipe = await methodInvoker.RegisterDuplexPipe(arguments.Item");
            sb.Append(DuplexPipeParameter!.SerializedId);
            sb.AppendLine(").ConfigureAwait(false);");
        }

        sb.AppendLine("                        this.Context.Logger?.Log((this.Context.Logger.Behaviors & global::NexNet.Logging.NexusLogBehaviors.LocalInvocationsLogAsInfo) != 0 ");
        sb.AppendLine("                            ? global::NexNet.Logging.NexusLogLevel.Information");
        sb.Append("                            : global::NexNet.Logging.NexusLogLevel.Debug, this.Context.Logger.Category, null, $\"Invoking Method: ");

        EmitNexusMethodInvocation(sb, true);
        sb.AppendLine("\");");
        sb.Append("                        ");
        
        // Ignore the return value if we are a void method or a duplex pipe method
        if (IsReturnVoid)
        {
            EmitNexusMethodInvocation(sb, false);
        }
        else if (IsAsync)
        {
            // If we are async, we need to await the method invocation and then serialize the return value otherwise
            // we can just invoke the method and serialize the return value
            if (IsAsync && ReturnType == null)
            {
                sb.Append("await ");
                EmitNexusMethodInvocation(sb, false);
            }
            else
            {
                sb.Append("var result = await ");
                EmitNexusMethodInvocation(sb, false);
                sb.AppendLine("""
                        if (returnBuffer != null)
                            global::MemoryPack.MemoryPackSerializer.Serialize(returnBuffer, result);
""");
            }
        }
    }

    /// <summary>
    /// Emits the invocation of the method on the nexus.
    /// </summary>
    /// <param name="sb"></param>
    /// <param name="forLog">Change the output to write the output params. Used for logging.</param>
    public void EmitNexusMethodInvocation(StringBuilder sb, bool forLog)
    {
        sb.Append(this.Name).Append("(");

        
        bool addedParam = false;
        foreach (var methodParameterMeta in Parameters)
        {
            // If we have a duplex pipe, we need to pass it in the correct parameter position,
            // otherwise we need to pass the serialized value.
            if (methodParameterMeta.IsDuplexPipe)
            {
                if (forLog)
                {
                    sb.Append(methodParameterMeta.Name)
                        .Append(" = {arguments.Item")
                        .Append(DuplexPipeParameter!.SerializedId)
                        .Append("}, ");
                }
                else
                {
                    sb.Append("duplexPipe, ");
                }

                addedParam = true;
            }
            else if (methodParameterMeta.IsDuplexUnmanagedChannel)
            {
                if (forLog)
                {
                    sb.Append(methodParameterMeta.Name)
                        .Append(" = {arguments.Item")
                        .Append(DuplexPipeParameter!.SerializedId)
                        .Append("}, ");
                }
                else
                {
                    sb.Append("global::NexNet.Pipes.NexusDuplexPipeExtensions.GetUnmanagedChannel<");
                    sb.Append(methodParameterMeta.ChannelType);
                    sb.Append(">(duplexPipe), ");
                }

                addedParam = true;
            }
            else if (methodParameterMeta.IsDuplexChannel)
            {
                if (forLog)
                {
                    sb.Append(methodParameterMeta.Name)
                        .Append(" = {arguments.Item")
                        .Append(DuplexPipeParameter!.SerializedId)
                        .Append("}, ");
                }
                else
                {
                    sb.Append("global::NexNet.Pipes.NexusDuplexPipeExtensions.GetChannel<");
                    sb.Append(methodParameterMeta.ChannelType);
                    sb.Append(">(duplexPipe), ");
                }

                addedParam = true;
            }
            else if (methodParameterMeta.SerializedValue != null)
            {
                if (forLog)
                {
                    sb.Append(methodParameterMeta.Name)
                        .Append(" = {arguments.Item")
                        .Append(methodParameterMeta.SerializedId)
                        .Append("}, ");
                }
                else
                {
                    sb.Append("arguments.Item").Append(methodParameterMeta.SerializedId).Append(", ");
                }

                addedParam = true;
            }
        }

        if (CancellationTokenParameter != null)
        {
            if (forLog)
            {
                sb.Append(CancellationTokenParameter.Name).Append(" = ct");
            }
            else
            {
                sb.Append("cts.Token");
            }
        }
        else
        {
            if(addedParam)
                sb.Remove(sb.Length - 2, 2);
        }
        
        // Configure the await if the method is not a void return type.
        sb.Append(")").Append((this.IsReturnVoid || forLog) ? ";" : ".ConfigureAwait(false);");

        if (!forLog)
            sb.AppendLine();
    }

    public void EmitProxyMethodInvocation(StringBuilder sb)
    {
        sb.Append("             public ");

        if (this.IsReturnVoid)
        {
            sb.Append("void ");
        }
        else if (this.IsAsync)
        {
            if (this.ReturnType != null)
            {
                sb.Append("global::System.Threading.Tasks.ValueTask<").Append(this.ReturnType).Append("> ");
            }
            else
            {
                sb.Append("global::System.Threading.Tasks.ValueTask ");
            }
        }

        sb.Append(this.Name).Append("(");

        foreach (var parameter in Parameters)
        {
            sb.Append(parameter.ParamType).Append(" ").Append(parameter.Name).Append(", ");
        }

        if(Parameters.Length > 0)
            sb.Remove(sb.Length - 2, 2);
        
        sb.AppendLine(")");
        sb.AppendLine("             {");
        sb.AppendLine("                 var __proxyInvoker = global::System.Runtime.CompilerServices.Unsafe.As<global::NexNet.Invocation.IProxyInvoker>(this);");
        if (SerializedParameters > 0)
        {
            sb.Append("                 var __proxyInvocationArguments = new global::System.ValueTuple<");
            
            
            foreach (var p in Parameters)
            {
                if(p.SerializedType == null)
                    continue;

                sb.Append(p.SerializedType).Append(", ");
            }

            sb.Remove(sb.Length - 2, 2);

            sb.Append(">(");
            foreach (var p in Parameters)
            {
                if (p.SerializedValue == null)
                    continue;

                sb.Append(p.SerializedValue).Append(", ");
            }

            sb.Remove(sb.Length - 2, 2);

            sb.AppendLine(");");
        }

        // Logging
        sb.Append("                 __proxyInvoker.Logger?.Log((__proxyInvoker.Logger.Behaviors & global::NexNet.Logging.NexusLogBehaviors.ProxyInvocationsLogAsInfo) != 0 ? global::NexNet.Logging.NexusLogLevel.Information : global::NexNet.Logging.NexusLogLevel.Debug, __proxyInvoker.Logger.Category, null, $\"Proxy Invoking Method: ");
        sb.Append(this.Name).Append("(");
        for (var i = 0; i < Parameters.Length; i++)
        {
            if (Parameters[i].IsCancellationToken)
            {
                sb.Append(Parameters[i].Name)
                    .Append(", ");
            }
            else
            {
                sb.Append(Parameters[i].Name)
                    .Append(" = ")
                    .Append("{__proxyInvocationArguments.Item").Append(i + 1)
                    .Append("}, ");
            }
        }

        if (Parameters.Length > 0) 
            sb.Remove(sb.Length - 2, 2);
        
        sb.AppendLine(");\");");
        sb.Append("                 ");


        if (this.IsReturnVoid || this.DuplexPipeParameter != null)
        {
            // If we are a void method, we need to invoke the method and then ignore the return
            // If we have a duplex pipe parameter, we need to invoke the method and then return the invocation result.
            sb.Append(this.DuplexPipeParameter == null ? "_ = " : "return ");

            sb.Append("__proxyInvoker.ProxyInvokeMethodCore(").Append(this.Id).Append(", ");
            sb.Append(SerializedParameters > 0 ? "__proxyInvocationArguments, " : "null, ");

            // If we have a duplex pipe parameter, we need to pass the duplex pipe invocation flag.
            sb.Append("global::NexNet.Messages.InvocationFlags.").Append(this.DuplexPipeParameter == null ? "None" : "DuplexPipe").AppendLine(");");
        }
        else if (this.IsAsync)
        {
            sb.Append("return __proxyInvoker.ProxyInvokeAndWaitForResultCore");
            if (this.ReturnType != null)
            {
                sb.Append("<").Append(this.ReturnType).Append(">");
            }

            sb.Append("(").Append(this.Id).Append(", "); // methodId
            sb.Append(SerializedParameters > 0 ? "__proxyInvocationArguments, " : "null, "); // arguments
            sb.Append(CancellationTokenParameter != null ? CancellationTokenParameter.Name : "null").AppendLine(");");
        }

        sb.AppendLine("             }");
    }
    
    public override string ToString()
    {
        var sb = SymbolUtilities.GetStringBuilder();

        if (IsReturnVoid)
        {
            sb.Append("void");
        }
        else if (IsAsync)
        {
            sb.Append("ValueTask");

            if (this.ReturnArity > 0)
            {
                sb.Append("<").Append(this.ReturnTypeSource).Append(">");
            }
        }

        sb.Append(" ");
        sb.Append(this.Name).Append("(");

        var paramsLength = this.Parameters.Length;
        if (paramsLength > 0)
        {
            for (int i = 0; i < paramsLength; i++)
            {
                sb.Append(Parameters[i].ParamTypeSource);
                sb.Append(" ");
                sb.Append(Parameters[i].Name);

                if (i + 1 < paramsLength)
                {
                    sb.Append(", ");
                }
            }
        }

        sb.Append(")");

        var stringMethod = sb.ToString();

        SymbolUtilities.ReturnStringBuilder(sb);

        return stringMethod;
    }
}

partial class CollectionMeta
{
    /// <summary>
    /// Emit the code for the the nexus.
    /// </summary>
    /// <param name="sb"></param>
    public void EmitNexusInvocation(StringBuilder sb)
    {
        sb.Append(@"
                        var arguments = message.DeserializeArguments<global::System.ValueTuple<global::System.Byte>>();
                        duplexPipe = await methodInvoker.RegisterDuplexPipe(arguments.Item1).ConfigureAwait(false);
                        this.Context.Logger?.Log((this.Context.Logger.Behaviors & global::NexNet.Logging.NexusLogBehaviors.LocalInvocationsLogAsInfo) != 0 
                                ? global::NexNet.Logging.NexusLogLevel.Information
                                : global::NexNet.Logging.NexusLogLevel.Debug, this.Context.Logger.Category, null, $""Nexus ").Append(CollectionTypeShortString).Append(" Collection connection Invocation: ").Append(Name).Append(@" pipe = {arguments.Item1}"");
    
                        await global::System.Runtime.CompilerServices.Unsafe.As<global::NexNet.Invocation.ICollectionStore>(this).StartCollection(").Append(Id).AppendLine(", duplexPipe);");
    }
    
    public void EmitCollectionConfigure(StringBuilder sb)
    {
        sb.Append("            manager.ConfigureList<").Append(this.ReturnTypeArity).Append(">(").Append(Id).Append(", ").Append(CollectionModeFullTypeString).AppendLine(");");
    }
    

    public void EmitProxyAccessor(StringBuilder sb)
    {
        sb.Append("            public ");
        sb.Append(CollectionTypeFullString);

        if (this.ReturnArity > 0)
        {
            sb.Append("<").Append(this.ReturnTypeArity).Append(">");
        }

        sb.Append(" ");
        sb.Append(this.Name).Append(" => global::System.Runtime.CompilerServices.Unsafe.As<global::NexNet.Invocation.IProxyInvoker>(this).");
        sb.Append(CollectionType switch
        {
            CollectionTypeValues.List => "ProxyGetConfiguredNexusList<",
            _ => "INVALID"
        }).Append(this.ReturnTypeArity).Append(">(");
        
        sb.Append(this.Id).AppendLine(");");
    } 
    
    public void EmitNexusAccessor(StringBuilder sb)
    {
        sb.Append("    public ");
        sb.Append(CollectionTypeFullString);

        if (this.ReturnArity > 0)
        {
            sb.Append("<").Append(this.ReturnTypeArity).Append(">");
        }

        sb.Append(" ");
        sb.Append(this.Name).Append(" => global::System.Runtime.CompilerServices.Unsafe.As<global::NexNet.Invocation.ICollectionStore>(this).");
        sb.Append(CollectionType switch
        {
            CollectionTypeValues.List => "GetList<",
            _ => "INVALID",
        }).Append(this.ReturnTypeArity).Append(">(");
        
        sb.Append(this.Id).Append(");");
    }
    
    public override string ToString()
    {
        var sb = SymbolUtilities.GetStringBuilder();

        // Use the short name description.
        if (this.ReturnArity > 0)
        {
            sb.Append(this.ReturnTypeSource).Append("(").Append(this.Id).Append(");");;
        }
        
        var stringMethod = sb.ToString();

        SymbolUtilities.ReturnStringBuilder(sb);

        return stringMethod;
    }
}


partial class InvocationInterfaceMeta
{
    public void EmitProxyImpl(StringBuilder sb, InvocationInterfaceMeta? proxyInterface)
    {
        sb.AppendLine($$"""

        /// <summary>
        /// Proxy invocation implementation for the matching nexus.
        /// </summary>
        public class {{ProxyImplName}} : global::NexNet.Invocation.ProxyInvocationBase, {{this.Namespace}}.{{this.TypeName}}, global::NexNet.Invocation.IInvocationMethodHash
        {
""");
        if (proxyInterface != null)
        {
            foreach (var collection in proxyInterface.Collections)
            {
                collection.EmitProxyAccessor(sb);
                sb.AppendLine();
            }
        }

        foreach (var method in AllMethods)
        {
            method.EmitProxyMethodInvocation(sb);
        }


        sb.Append($$"""

            /// <summary>
            /// Hash for methods on this proxy or nexus.  Used to perform a simple client and server match check.
            /// </summary>
            static int global::NexNet.Invocation.IInvocationMethodHash.MethodHash { get => {{GetHash()}}; }
            
            /// <summary>
            /// Hash table for all the versions that this nexus implements.
            /// </summary>
            static global::System.Collections.Frozen.FrozenDictionary<string, int> global::NexNet.Invocation.IInvocationMethodHash.VersionHashTable { get; } = 
""");

        if (NexusAttribute.IsServer)
        {
            // 
            sb.AppendLine("global::System.Collections.Frozen.FrozenDictionary<string, int>.Empty;");
        }
        else
        {
            // On the client proxy, we only emit the version ID specified on the nexus interface.
            var lastVersion = Versions.LastOrDefault();
            var versionName = lastVersion == null
                ? VersionAttribute.Version ?? ""
                : lastVersion.VersionAttribute.Version;
            sb.AppendLine(
                "global::System.Collections.Frozen.FrozenDictionary.ToFrozenDictionary(new global::System.Collections.Generic.KeyValuePair<string, int>[] {");
            sb.Append("                new(\"").Append(versionName).Append("\", ").Append(lastVersion?.GetHash() ?? GetHash()).AppendLine("),");
                    sb.AppendLine("""
            });
""");
        }
        
        sb.AppendLine("""
        }
""");
        
    }
    
    public override string ToString()
    {
        return this.TypeName;
    }
}

