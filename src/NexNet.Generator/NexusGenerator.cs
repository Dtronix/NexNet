using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NexNet.Generator.Emission;
using NexNet.Generator.Extraction;
using NexNet.Generator.Models;
using NexNet.Generator.Validation;

namespace NexNet.Generator;

[Generator(LanguageNames.CSharp)]
internal partial class NexusGenerator : IIncrementalGenerator
{
    public const string NexusAttributeFullName = "NexNet.NexusAttribute`2";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // TRANSFORM PHASE: Extract all data here - this is cached by the incremental pipeline
        // The transform runs during semantic analysis and extracts all data into equatable records.
        // When the extracted data hasn't changed, the output phase is skipped entirely.
        var nexusData = context.SyntaxProvider.ForAttributeWithMetadataName(
            NexusAttributeFullName,
            predicate: static (node, _) => node is ClassDeclarationSyntax,
            transform: static (ctx, ct) => NexusDataExtractor.Extract(ctx, ct))
            .Where(static data => data is not null)!;

        var parseOptions = context.ParseOptionsProvider.Select(static (opts, _) =>
            ((CSharpParseOptions)opts).LanguageVersion);

        // Combine with language version only (NOT full compilation)
        // This is the key change - we no longer depend on CompilationProvider
        // which changes on every keystroke in any file.
        var source = nexusData.Combine(parseOptions);

        // OUTPUT PHASE: Use only extracted data - no semantic model access
        // This phase only runs when the extracted data actually changes.
        context.RegisterSourceOutput(source, static (ctx, source) =>
        {
            var (data, langVersion) = source;
            Generate(data!, langVersion, ctx);
        });
    }

    private static void Generate(
        NexusGenerationData data,
        LanguageVersion langVersion,
        SourceProductionContext context)
    {
        // Validate using cached data (no ISymbol references)
        var diagnostics = NexusValidator.Validate(data, context.CancellationToken);

        bool hasBlockingErrors = false;
        foreach (var diagnostic in diagnostics)
        {
            context.ReportDiagnostic(diagnostic);
            // HashLock mismatch is an error but shouldn't block generation
            if (diagnostic.Severity == DiagnosticSeverity.Error &&
                diagnostic.Id != DiagnosticDescriptors.VersionHashLockMismatch.Id)
            {
                hasBlockingErrors = true;
            }
        }

        if (hasBlockingErrors)
            return;

        // Generate code using cached data
        var sb = SymbolUtilities.GetStringBuilder();

        sb.AppendLine(@"// <auto-generated/>
#nullable enable
");

        var code = NexusEmitter.Emit(data, langVersion);
        sb.Append(code);

        var finalCode = sb.ToString();
        SymbolUtilities.ReturnStringBuilder(sb);

        context.AddSource($"{data.FullTypeName}.Nexus.g.cs", finalCode);
    }
}
